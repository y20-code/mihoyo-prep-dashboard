function intersection(nums1:number[],nums2:number[]):number[]{
    const set1 = new Set(nums1);
    const result = new Set<number>();

    for(let i of nums2){
        if(set1.has(i)){
            result.add(i);
        }
    }

    return Array.from(result);
}

function moveZeroes(nums:number[]):void{
    let slow = 0;
    

    for(let fast = 0;fast<nums.length;fast++){
        if(nums[fast]){
            [nums[slow],nums[fast]] = [nums[fast],nums[slow]]
        }
        slow++
    }

    return nums;
}

function isAnagram(s:string,t:string):boolean{

    const arr = new Array(26).fill(0)

    const base = 97;

    for(let i  = 0;i<s.length;i++){
        arr[s.charCodeAt(i)-base]++
        arr[t.charCodeAt(i)-base]--
    }

    return arr.every(val => val ===0)
}


function containsDuplicate(nums: number[]): boolean {
    const set = new Set(nums);
    return nums.length !== set.length
}

function twoSum(nums: number[], target: number): number[] {
    
}

function groupAnagrams(strs: string[]): string[][] {
    const result = new Map<string,string[]>();

    for(let str of strs){
        const tar = str.split('').sort().join('');
        if(!result.has(tar)){
            result.set(tar,[])
        }

        result.get(tar)!.push(str)
    }

    return Array.from(result.values())
}

function reverseList(head: ListNode | null): ListNode | null {
    let prev = null;
    let curr = head;

    while(curr !==null){
        const nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }

    return prev
}

// 1. 算出平方和
function getNext(n: number): number {

    let sum = 0;


    while(n!==0){
        let g = n % 10;
        sum += g * g;
        n = Math.floor(n/10);
    }

    return sum
}

function lengthOfLongestSubstring(s: string): number {
    const set = new Set();
    let slow = 0;

    let maxLen = 0;

    for(let fast = 0;fast<s.length;fast++){
        
        while(set.has(s[fast])){
            set.delete(s[slow])

            slow++
        }

        set.add(s[fast])

        maxLen = Math.max(maxLen,fast - slow +1)
    }

    return maxLen

}

function hasCycle(head:ListNode | null): boolean{
    let slow = head;
    let fast = head;
    while (fast !==null && fast.next !==null){
        slow = slow.next;
        fast = fast.next.next;

        if(slow === fast) {
            return true;
        }
    }

    return false;
}