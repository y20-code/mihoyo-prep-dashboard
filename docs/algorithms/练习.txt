function twoSum(nums: number[], target: number): number[] {
    const map = new Map<number,number>();
    for(let i = 0;i < nums.length;i++){
        const complement = target - nums[i];

        if(map.has(complement)){
            return [map.get(complement)!,i];
        }

        map.set(nums[i],i);
    }

    return[]
    
}

function lengthOfLongestSubstring(s: string): number {
    
    const set = new Set<string>();
    let left = 0;
    let maxLen = 0;

    for(let i = 0;i < s.length;i++){
        while(set.has(s[i])){
            set.delete(s[left]);
            left++;
        }
        
        set.add(s[i]);

        maxLen = Math.max(maxLen,set.size);
    }

    return maxLen;
}

function threeSum(nums: number[]): number[][] {
    const result: number[][] = [];
    // 1. 必须正确排序 (从小到大)
    nums.sort((a, b) => a - b);
    
    for (let i = 0; i < nums.length; i++) {
        // [去重逻辑 1]：如果当前的数 nums[i] 已经大于 0，
        // 后面怎么加都不可能等于 0 (因为数组排过序了)，直接结束
        if (nums[i] > 0) break;

        // [去重逻辑 2]：针对 i 的去重。
        // 如果这个数和前一个数一样，跳过！因为前面那个数已经把所有组合找过了
        if (i > 0 && nums[i] === nums[i-1]) continue;

        let left = i + 1;
        let right = nums.length - 1;

        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right];

            if (sum === 0) {
                // 找到了！加入结果
                result.push([nums[i], nums[left], nums[right]]);

                // [去重逻辑 3]：针对 left 和 right 的去重 (关键！)
                // 如果左边下一个数还是一样，一直跳过
                while (left < right && nums[left] === nums[left+1]) left++;
                // 如果右边前一个数还是一样，一直跳过
                while (left < right && nums[right] === nums[right-1]) right--;
                
                // 找到答案后，两边同时收缩
                left++;
                right--;
            } else if (sum < 0) {
                // 和太小，左指针右移 (让数变大点)
                left++;
            } else {
                // 和太大，右指针左移 (让数变小点)
                right--;
            }
        }
    }
    
    return result;
}


function isValid(s: string): boolean {
    if(s.length % 2 !==0) return false;

    const map = new Map([
        [')','('],
        ['}','{'],
        [']','[']
    ])

    const stack:string[] = [];

    for(let i = 0;i < s.length;i++){
        if(map.has(s[i])){
            let complement = stack.pop();
            if(map.get(s[i]) !== complement){
                return false;
            }
        }else{
            stack.push(s[i]);
        }
    }

    return stack.length === 0;

}

function reverseList(head: ListNode | null): ListNode | null {
    // 请开始写代码
    // 提示：你需要三个指针：prev, curr, next

    let prev = null;
    let curr = head;

    while(curr!==null){
        let nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }

    return prev;
    
}

function hasCycle(head: ListNode | null): boolean {
    // 请开始写代码
    let slow = head;
    let fast = head;

    while(fast !== null && fast.next !== null){
        slow = slow.next;
        fast = fast.next.next;
        if(fast === slow){
            return true;
        }
    }

    return false;
}


