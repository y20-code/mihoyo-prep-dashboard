/**
 * =================================================================
 * 【日常实习】米哈游特训 Day 4：This 指向与 setTimeout 深度解析
 * =================================================================
 * * 核心心法：
 * 1. 普通函数：看调用位置。谁调用 (.)，指向谁；没人调用，指向 Window/undefined。
 * 2. 箭头函数：看出生位置。它是“啃老族”，继承外层作用域的 this。
 * 3. setTimeout：是“剥离器”，传进去的函数会变成“裸奔调用”，导致 this 丢失。
 */

// ============================================
// 一、普通函数 vs 箭头函数 (基础内功)
// ============================================

const player = {
    name: '旅行者',
    
    // 1. 普通函数：看调用
    sayNormal: function() {
        console.log(`[普通] 我是 ${this.name}`);
    },

    // 2. 箭头函数：看定义 (陷阱深度解析)
    // 核心原理：对象的大括号 {} 不是作用域(Scope)，它对于 this 来说是透明的！
    // 箭头函数在定义时，往外找“爸爸”。
    // 因为 player {} 不是函数，挡不住它，所以它直接看穿到了全局 (Window)。
    sayArrow: () => {
        console.log(`[箭头] 我是 ${this.name}`); 
    }
};

console.log('--- 基础测试 ---');
player.sayNormal(); // 输出: "旅行者" (有 player. 调用)
player.sayArrow();  // 输出: undefined 或 "" (箭头函数不认 player 做老板)


// ============================================
// 二、setTimeout 的“剥离”陷阱 (核心考点)
// ============================================

const klee = {
    name: '可莉',
    bomb: function() {
        console.log(`${this.name} 的炸弹爆炸了！BOOM!`);
    }
};

console.log('\n--- setTimeout 陷阱测试 ---');

// 【错误写法 1】直接传引用
// 原理：相当于把 bomb 函数的代码抄写给了浏览器，klee 被扔下了。
// 浏览器 1秒后执行的是“裸奔”的函数，this 变成了 Window。
setTimeout(klee.bomb, 500); // 输出: "undefined 的炸弹爆炸了！"


// 【错误写法 2】加了括号 (你刚才问的)
// 原理：JS 引擎读到 () 会“立即执行”。
// 结果：还没等 1秒，立刻就打印了。传给 setTimeout 的是函数的返回值 (undefined)。
// setTimeout(klee.bomb(), 500); 


// ============================================
// 三、米哈游标准解法 (如何把 this 找回来)
// ============================================

console.log('\n--- 修复方案测试 (1秒后见证奇迹) ---');

// 【方案 A：推荐】箭头函数包裹 (加个管家)
// 原理：浏览器喊管家(箭头函数)，管家认识 klee，管家去喊 klee.bomb()。
// 这里的 klee.bomb() 是带点调用的，所以 this 稳了。
setTimeout(() => {
    klee.bomb(); 
}, 1000); 


// 【方案 B：备选】Bind 硬绑定 (强力胶水)
// 原理：强制把 klee 焊死在函数上，生成一个新函数传给浏览器。
setTimeout(klee.bomb.bind(klee), 1000);


// ============================================
// 四、综合实战复习 (钟离的考验)
// ============================================

const zhongli = {
    name: '钟离',
    skill: function() {
        console.log(`\n[终极测试] ${this.name}：天动万象！`);
    }
};

// 思考：下面这行代码实际上发生了什么？
// 1. 查找 zhongli.skill 的内存地址。
// 2. 把这个地址赋值给一个临时变量。
// 3. 这里的 this 就丢失了。
const tempSkill = zhongli.skill;
// tempSkill(); // 如果取消注释，this 是 undefined

// 正确做法：
setTimeout(() => zhongli.skill(), 2000);

/**
 * =================================================================
 * 总结口诀 (背诵全文)：
 * * 1. obj.func()   -> this 是 obj
 * 2. func()       -> this 是 Window (裸奔)
 * 3. () => {}     -> this 往外找 (继承)
 * 4. setTimeout   -> 容易把 this 弄丢 (变成裸奔)
 * - 救命招式 1: setTimeout(() => obj.func(), 1000) (最稳)
 * - 救命招式 2: setTimeout(obj.func.bind(obj), 1000)
 * =================================================================
 */

/**
 * =================================================================
 * 【日常实习】米哈游特训 Day 4：This 指向与 setTimeout 深度解析 (完整版)
 * =================================================================
 * * 核心心法：
 * 1. 普通函数：看调用位置。谁调用 (.)，指向谁；没人调用，指向 Window/undefined。
 * 2. 箭头函数：看出生位置。它是“啃老族”，继承外层作用域的 this。
 * 3. setTimeout：是“剥离器”，传进去的函数会变成“裸奔调用”，导致 this 丢失。
 */

// ... (前面一至四的部分保持不变，这里省略，直接看新增的第五部分) ...

// ============================================
// 五、高阶函数特技 (什么时候可以用括号？)
// ============================================

console.log('\n--- 高阶函数 / 闭包特技测试 ---');

/**
 * 很多面试官会问：setTimeout(obj.func(), 1000) 一定是错的吗？
 * 答案：不一定。如果 func() 返回的是另一个函数，那就是对的！
 * 这叫【高阶函数】。
 */

const mona = {
    name: '莫娜',
    // 这是一个高阶函数：执行它，它不干活，而是返回一个新的函数
    setupMagic: function() {
        console.log(`[立即执行] ${this.name} 正在布置水占盘...`);
        
        // 保存当前的 this (或者利用箭头函数继承)
        const that = this; 
        
        // 返回一个新的函数给 setTimeout
        return function() {
            // 这里利用了闭包，访问了外层的 that
            console.log(`[1秒后执行] ${that.name}：命运既定！`);
        };
    }
};

// 【特例写法】这里加了括号 ()
// 解析：
// 1. mona.setupMagic() 立即执行 -> 打印 "正在布置..."
// 2. 它返回了一个新函数 (那个 return 后面的 function)
// 3. setTimeout 接收到了这个新函数，1秒后执行它
setTimeout(mona.setupMagic(), 1000);

/**
 * =================================================================
 * 总结口诀 (背诵全文)：
 * * 1. obj.func()     -> this 是 obj
 * 2. func()         -> this 是 Window (裸奔)
 * 3. () => {}       -> this 往外找 (继承)
 * 4. setTimeout     -> 容易把 this 弄丢
 * - 救命招 A: setTimeout(() => obj.func(), 1000) (最稳)
 * - 救命招 B: setTimeout(obj.func.bind(obj), 1000)
 * - 特技: setTimeout(obj.makeFunc(), 1000) (利用高阶函数返回)
 * =================================================================
 */