// # Day 3: 前端内功 - 原型与原型链 (MiHoYo 特训版)

// 1. 核心口诀
// - **__proto__ (隐式原型)**: 对象的“寻宝地图”，指向爸爸。所有对象都有。
// - **prototype (显式原型)**: 函数的“基因库/武器库”，给子孙用的。只有函数有。
// - **constructor**: 既然是借来的武器，得知道是谁造的。指向构造函数本身。

// ## 2. 内存查找机制 (寻宝路径)
// 当访问 `arr.push()` 时：
// 1. **自身查找**: `arr` 身上有 `push` 吗？ -> 无。
// 2. **顺藤摸瓜**: 沿着 `arr.__proto__` 找到 `Array.prototype`。
// 3. **命中目标**: 在 `Array.prototype` 里找到了 `push`，调用之。
// *设计哲学*: 共享内存，省空间 (1万个对象共用1套方法)。

// ## 3. 属性遮蔽 (Property Shadowing)
// - 如果在对象**自身**定义了和原型同名的方法 (如 `arr.push = function...`)，会优先用自己的。
// - 原则: **就近原则**。

// ## 4. instanceof 的谎言与真相
// - **原理**: 不看名字，看**地址**。顺着左边对象的 `__proto__` 链条往上爬，看能不能碰到右边构造函数的 `prototype` 地址。
// - **特例**: `Object.create(null)` 创建的对象是“孤儿”，没有 `__proto__`，所以 `instanceof Object` 为 `false`。

// ## 5. 链条终点
// - `Object.prototype.__proto__ === null`。 (大道至简，归于虚无)。